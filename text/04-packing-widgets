Packing Widgets

When creating an application, you'll want to put more than one widget inside a 
window. Our first helloworld example only used one widget so we could simply use 
the [CODE]Gtk.Container[/CODE] [CODE]add()[/CODE] method to "pack" the widget 
into the window. But when you want to put more than one widget into a window, 
how do you control where that widget is positioned? This is where packing comes 
in.




Theory of Packing Boxes

Most packing is done by creating boxes. These are invisible widget containers 
that we can pack our widgets into which come in two forms, a horizontal box, 
and a vertical box. When packing widgets into a horizontal box, the objects are 
inserted horizontally from left to right or right to left depending on the call 
used. In a vertical box, widgets are packed from top to bottom or vice versa. 
You may use any combination of boxes inside or beside other boxes to create the 
desired effect.

To create a new horizontal box, we use a call to [CODE]Gtk.HBox()[/CODE], and 
for vertical boxes, [CODE]Gtk.VBox()[/CODE]. The [CODE]pack_start()[/CODE] and 
[CODE]pack_end()[/CODE] methods are used to place objects inside of these 
containers. The [CODE]pack_start()[/CODE] method will start at the top and work 
its way down in a vbox, and pack left to right in an hbox. The [CODE]pack_end()[CODE] 
method will do the opposite, packing from bottom to top in a vbox, and right to 
left in an hbox. Using these methods allows us to right justify or left justify 
our widgets and may be mixed in any way to achieve the desired effect. We will 
use [CODE]pack_start()[/CODE] in most of our examples. An object may be another 
container or a widget. In fact, many widgets are actually containers themselves, 
including the button, but we usually only use a label inside a button.

By using these calls, GTK knows where you want to place your widgets so it can 
do automatic resizing and other nifty things. There are also a number of options 
as to how your widgets should be packed. As you can imagine, this method gives 
us a quite a bit of flexibility when placing and creating widgets.




Details of Boxes

Because of this flexibility, packing boxes in GTK can be confusing at first. 
There are a lot of options, and it's not immediately obvious how they all fit 
together. In the end, however, there are basically five different styles. 

Figure 4.1, “Packing: Five Variations” illustrates the result of running the 
program packbox.py with an argument of 1:


[IMG file="chapter-04/01Packbox_1"]Figure 4.1. Packing: Five Variations[/IMG]


Each line contains one horizontal box (hbox) with several buttons. The call to 
pack is shorthand for the call to pack each of the buttons into the hbox. Each 
of the buttons is packed into the hbox the same way (i.e., same arguments to the 
[CODE]pack_start()[/CODE] method).

This is an example of the [CODE]pack_start()[/CODE] method.

[CODE]
  box.pack_start(child, expand, fill, padding)
[/CODE]

[CODE]box[/CODE] is the box you are packing the object into; the first argument 
is the child object to be packed. The objects will all be buttons for now, so 
we'll be packing buttons into boxes.

The expand argument to [CODE]pack_start()[/CODE] and [CODE]pack_end()[/CODE] 
controls whether the widgets are laid out in the box to fill in all the extra 
space in the box so the box is expanded to fill the area allotted to it (True); 
or the box is shrunk to just fit the widgets (False). Setting expand to False 
will allow you to do right and left justification of your widgets. Otherwise, 
they will all expand to fit into the box, and the same effect could be achieved 
by using only one of [CODE]pack_start()[/CODE] or [CODE]pack_end()[/CODE].

The fill argument to the pack methods control whether the extra space is 
allocated to the objects themselves ([CODE]true[/CODE]), or as extra padding in 
the box around these objects ([CODE]false[/CODE]). It only has an effect if the 
expand argument is also [CODE]true[/CODE].

Python allows a method or function to be defined with default argument values 
and argument keywords. Throughout this tutorial I'll show the definition of the 
functions and methods with defaults and keywords bolded as applicable. For 
example the [CODE]pack_start()[/CODE] method is defined as:

[CODE]
  box.pack_start(child, expand=True, fill=True, padding=0)

  box.pack_end(child, expand=True, fill=True, padding=0)
[/CODE]

child, expand, fill and padding are keywords. The expand, fill and padding 
arguments have the defaults shown. The child argument must be specified.

When creating a new box, the function looks like this:

[CODE]
  hbox = gtk.HBox(homogeneous=False, spacing=0)

  vbox = gtk.VBox(homogeneous=False, spacing=0)
[/CODE]

The homogeneous argument to [CODE]Gtk.HBox()[/CODE] and [CODE]Gtk.VBox()[/CODE] 
controls whether each object in the box has the same size (i.e., the same width 
in an hbox, or the same height in a vbox). If it is set, the pack routines 
function essentially as if the expand argument was always turned on.

What's the difference between spacing (set when the box is created) and padding 
(set when elements are packed)? Spacing is added between objects, and padding 
is added on either side of an object. Figure 4.2, “Packing with Spacing and 
Padding” illustrates the difference; pass an argument of 2 to packbox.py :

[IMG file="chapter-04/01_Packbox_2"]Packing with Spacing and Padding[/IMG]


Figure 4.3, “Packing with [CODE]pack_end()[/CODE]” illustrates the use of the 
[CODE]pack_end()[/CODE] method (pass an argument of 3 to packbox.py). The label 
"end" is packed with the [CODE]pack_end()[/CODE] method. It will stick to the 
right edge of the window when the window is resized.

[IMG file="chapter-07/01_Packbox_3"]Packing with pack_end()[/IMG]




Packing Demonstration Program

Here is the code used to create the above images. It's commented fairly heavily 
so I hope you won't have any problems following it. Compile and run it yourself
and play with it.

[CODE]

  using Gtk;

  /*
  * Helper function that makes a new hbox filled with button-labels. Arguments
  * for the variables we're interested are passed in to this function.  We do
  * not show the box, but do show everything inside.
  */
  static Gtk.HBox make_box (bool homogeneous, int spacing, bool expand, bool fill, int padding) {
    Gtk.HBox box;
    Gtk.Button button;
    string padstr;
      
    /* Create a new hbox with the appropriate homogeneous
    * and spacing settings */
    box = new Gtk.HBox(homogeneous, spacing);
    
    /* Create a series of buttons with the appropriate settings */
    button = new Gtk.Button.with_label("gtk_box_pack");
    box.pack_start(button, expand, fill, padding);
    button.show();
    
    button = new Gtk.Button.with_label ("(box,");
    box.pack_start(button, expand, fill, padding);
    button.show();
    
    button = new Gtk.Button.with_label("button,");
    box.pack_start(button, expand, fill, padding);
    button.show();
    
    /* Create a button with the label depending on the value of
    * expand. */
    if (expand == true)
            button = new Gtk.Button.with_label("TRUE,");
    else
            button = new Gtk.Button.with_label("FALSE,");
    
    box.pack_start(button, expand, fill, padding);
    button.show();
    
    /* This is the same as the button creation for "expand"
    * above, but uses the shorthand form. */
    button = new Gtk.Button.with_label(fill ? "TRUE," : "FALSE,");
    box.pack_start (button, expand, fill, padding);
    button.show();
    
    padstr = "$padding);";
    
    button = new Gtk.Button.with_label(padstr);
    box.pack_start(button, expand, fill, padding);
    button.show();
    
    return box;
  }

  class PackBox1 {
    
    public Gtk.Window window;
    
    public bool delete_event () {
      Gtk.main_quit();
      return false;
    }
    
    public PackBox1 (int which) {
      
      /* Create our window. */
      this.window = new Gtk.Window(Gtk.WindowType.TOPLEVEL);
      
      /* You should always remember to connect the delete_event signal
      * to the main window. This is very important for proper intuitive
      * behavior */
      
      this.window.delete_event.connect(this.delete_event);
      this.window.set_border_width(10);
      
      /* We create a vertical box (vbox) to pack the horizontal boxes into.
      * This allows us to stack the horizontal boxes filled with buttons one
      * on top of the other in this vbox. */
      var box1 = new Gtk.VBox(false, 0);
      
      /* Which example to show. These correspond to the pictures above. */
      switch (which) {
        case 1:
          /* create a new label. */
          var label = new Gtk.Label("HBox(false, 0)");
      
          /* Align the label to the left side.  We'll discuss this method
          * and others in the section on Widget Attributes. */
          label.set_alignment(0, 0);

          /* Pack the label into the vertical box (vbox box1).  Remember that 
          * widgets added to a vbox will be packed one on top of the other in
          *  order. */
          box1.pack_start(label, false, false, 0);
      
          /* Show the label. */ 
          label.show();
      
          /* Call our make box function - homogeneous = false, spacing = 0,
          * expand = false, fill = false, padding = 0 */
          var box2 = make_box(false, 0, false, false, 0);
          box1.pack_start(box2, false, false, 0);
          box2.show();

          /* Call our make box function - homogeneous = false, spacing = 0,
          * expand = true, fill = false, padding = 0 */
          box2 = make_box(false, 0, true, false, 0);
          box1.pack_start(box2, false, false, 0);
          box2.show();
      
          /* Args are: homogeneous, spacing, expand, fill, padding */
          box2 = make_box(false, 0, true, true, 0);
          box1.pack_start(box2, false, false, 0);
          box2.show();
      
          /* Creates a separator, we'll learn more about these later, 
          * but they are quite simple. */
          var separator = new Gtk.HSeparator();
      
          /* Pack the separator into the vbox. Remember each of these
          * widgets is being packed into a vbox, so they'll be stacked
          * vertically. */
          box1.pack_start(separator, false, true, 5);
          separator.show();
      
          /* Create another new label, and show it. */
          label = new Gtk.Label("HBox(true, 0)");
          label.set_alignment(0, 0);
          box1.pack_start(label, false, false, 0);
          label.show();
      
          /* Args are: homogeneous, spacing, expand, fill, padding */
          box2 = make_box(true, 0, true, false, 0);
          box1.pack_start(box2, false, false, 0);
          box2.show();
      
          /* Args are: homogeneous, spacing, expand, fill, padding */
          box2 = make_box(true, 0, true, true, 0);
          box1.pack_start(box2, false, false, 0);
          box2.show();
      
          /* Another new separator. */
          separator = new Gtk.HSeparator();
          /* The last 3 arguments to pack_start are:
          * expand, fill, padding. */
          box1.pack_start(separator, false, true, 5);
          separator.show();
          break;
        case 2:
          /* Create a new label, remember box1 is a vbox as created 
          * near the beginning of the constructor. */
          var label = new Gtk.Label("HBox(false, 10)");
          label.set_alignment( 0, 0);
          box1.pack_start(label, false, false, 0);
          label.show();
      
          /* Args are: homogeneous, spacing, expand, fill, padding. */
          var box2 = make_box(false, 10, true, false, 0);
          box1.pack_start(box2, false, false, 0);
          box2.show();
      
          /* Args are: homogeneous, spacing, expand, fill, padding */
          box2 = make_box(false, 10, true, true, 0);
          box1.pack_start(box2, false, false, 0);
          box2.show();
      
          var separator = new Gtk.HSeparator();
          /* The last 3 arguments to pack_start are:
          * expand, fill, padding. */
          box1.pack_start(separator, false, true, 5);
          separator.show();
      
          label = new Gtk.Label("HBox(false, 0)");
          label.set_alignment(0, 0);
          box1.pack_start(label, false, false, 0);
          label.show();
      
          /* Args are: homogeneous, spacing, expand, fill, padding. */
          box2 = make_box(false, 0, true, false, 10);
          box1.pack_start(box2, false, false, 0);
          box2.show();
      
          /* Args are: homogeneous, spacing, expand, fill, padding. */
          box2 = make_box(false, 0, true, true, 10);
          box1.pack_start(box2, false, false, 0);
          box2.show();
      
          separator = new Gtk.HSeparator();
          /* The last 3 arguments to pack_start are:
          * expand, fill, padding. */
          box1.pack_start(separator, false, true, 5);
          separator.show();
        break;
        case 3:
          /* This demonstrates the ability to use pack_end() to
          * right justify widgets. First, we create a new box as before. */
          var box2 = make_box(false, 0, false, false, 0);

          /* Create the label that will be put at the end. */
          var label = new Gtk.Label("end");
          /* Pack it using pack_end(), so it is put on the right
          * side of the hbox created in the make_box() call. */
          box2.pack_end(label, false, false, 0);
          /* Show the label. */
          label.show();
      
          /* Pack box2 into box1 */
          box1.pack_start(box2, false, false, 0);
          box2.show();
      
          /* A separator for the bottom. */
          var separator = new Gtk.HSeparator();
          
          /* This explicitly sets the separator to 400 pixels wide by 5
          * pixels high. This is so the hbox we created will also be 400
          * pixels wide, and the "end" label will be separated from the
          * other labels in the hbox. Otherwise, all the widgets in the
          * hbox would be packed as close together as possible.
          * separator.set_size_request(400, 5)
          * pack the separator into the vbox (box1) created near the start 
          * of the constructor. */ 
          box1.pack_start(separator, false, true, 5);
          separator.show();
          break;
      }
      
      /* Create another new hbox.. remember we can use as many as we need! */
      var quitbox = new Gtk.HBox(false, 0);
    
      /* Our quit button. */
      var button = new Gtk.Button.with_label("Quit");
    
      /* Setup the signal to terminate the program when the button is clicked */
      button.clicked.connect( () => { Gtk.main_quit(); } );
      /* Pack the button into the quitbox.
      * The last 3 arguments to pack_start are:
      * expand, fill, padding. */
      quitbox.pack_start(button, true, false, 0);
      /* pack the quitbox into the vbox (box1) */
      box1.pack_start(quitbox, false, false, 0);
    
      /* Pack the vbox (box1) which now contains all our widgets, into the
      * main window. */
      this.window.add(box1);
    
      /* And show everything left */
      button.show();
      quitbox.show();
      box1.show();
      
      /* Showing the window last so everything pops up at once. */
      this.window.show();
    }
    
    
    public static int main (string[] args) {
      
      if (args.length == 2) {
        
        Gtk.init(ref args);
        new PackBox1(int.parse(args[1]));
        
        /* And of course, our mainloop. */
        Gtk.main();
        
        /* Control returns here when Gtk.main_quit() is called. */
        return 0;
        
      } else {
        return 1;
      }
      
    }

  }
[/CODE]

A brief tour of the 01Packbox.vala code starts with lines 10-55 which define a 
helper function [CODE]make_box()[/CODE] that creates a horizontal box and 
populates it with buttons according to the specified parameters. A reference to 
the horizontal box is returned.

Lines 66-255 define the [CODE]PackBox1[/CODE] class initialization method 
[CODE]PackBox1()[CODE] that creates a window and a child vertical box that is 
populated with a different widget arrangement depending on the argument passed 
to it. If a 1 is passed, lines 85-150 create a window displaying the five 
unique packing arrangements that are available when varying the homogeneous, 
expand and fill parameters. If a 2 is passed, lines 151-195 create a window 
displaying the various combinations of fill with spacing and padding. Finally, 
if a 3 is passed, lines 196-226 create a window displaying the use of the 
[CODE]pack_start()[/CODE] method to left justify the buttons and 
[CODE]pack_end()[/CODE] method to right justify a label. Lines 229-254 create a 
horizontal box containing a button that is packed into the vertical box. The 
button "clicked" signal is connected to the [CODE]Gtk.main_quit()[/CODE] 
function to terminate the program.

Lines 260-273 check the command line arguments and exit the program by returning
[CODE]1[/CODE] from the [CODE]main()[/CODE] function if there isn't exactly one 
argument. Line 263 creates a [CODE]PackBox1[/CODE] instance. Line 266 invokes 
the [CODE]Gtk.main()[/CODE] function to start the GTK event processing loop.

In this example program, the references to the various widgets (except the 
window) are not saved in the object instance attributes because they are not 
needed later.




Packing Using Tables

Let's take a look at another way of packing - Tables. These can be extremely 
useful in certain situations.

Using tables, we create a grid that we can place widgets in. The widgets may 
take up as many spaces as we specify.

The first thing to look at, of course, is the Gtk.Table() constructor:

[CODE]
  table = new Gtk.Table(rows=1, columns=1, homogeneous=False)
[/CODE]

The first argument is the number of rows to make in the table, while the second, 
obviously, is the number of columns.

The homogeneous argument has to do with how the table's boxes are sized. If 
homogeneous is [CODE]true[/CODE], the table boxes are resized to the size of 
the largest widget in the table. If homogeneous is [CODE]false[/CODE], the size 
of a table's  boxes is dictated by the tallest widget in its same row, and the 
widest widget in its column.

The rows and columns are laid out from 0 to n, where n was the number specified 
in the call to [CODE]Gtk.Table()[/CODE]. So, if you specify [CODE]rows = 2[CODE] 
and [CODE]columns = 2[/CODE], the layout would look something like this:

   0          1          2
  0+----------+----------+
   |          |          |
  1+----------+----------+
   |          |          |
  2+----------+----------+
Note that the coordinate system starts in the upper left hand corner. To place 
a widget into a box, use the following method:

[CODE]
  table.attach(child, left_attach, right_attach, top_attach, bottom_attach,
               xoptions=EXPAND|FILL, yoptions=EXPAND|FILL, xpadding=0, ypadding=0)
[/CODE]

The table instance is the table you created with [CODE]Gtk.Table()[/CODE]. The 
first parameter ("child") is the widget you wish to place in the table.

The [CODE]left_attach[/CODE], [CODE]right_attach[/CODE], [CODE]top_attach[/CODE] 
and [CODE]bottom_attach[/CODE] arguments specify where to place the widget, and 
how many boxes to use. If you want a button in the lower right table entry of 
our 2x2 table, and want it to fill that entry ONLY, [CODE]left_attach[/CODE] would 
be = 1, [CODE]right_attach[/CODE] = 2, [CODE]top_attach[/CODE] = 1, 
[CODE]bottom_attach[/CODE] = 2.

Now, if you wanted a widget to take up the whole top row of our 2x2 table, you'd 
use [CODE]left_attach = 0[/CODE], [CODE]right_attach = 2[CODE/], 
[CODE]top_attach = 0[/CODE], [CODE]bottom_attach = 1[/CODE].

The [CODE]xoptions[/CODE] and [CODE]yoptions[/CODE] are used to specify packing 
options and may be bitwise OR'ed together to allow multiple options.

These options are:

FILL    If the table cell is larger than the widget, and FILL is specified, 
        the widget will expand to use all the room available in the cell.
SHRINK  If the table widget was allocated less space then was requested (usually 
        by the user resizing the window), then the widgets would normally just 
        be pushed off the bottom of the window and disappear. If SHRINK is 
        specified, the widgets will shrink with the table.
EXPAND  This will cause the table cell to expand to use up any remaining space 
        allocated to the table.
Padding is just like in boxes, creating a clear area around the widget specified 
        in pixels.

We also have [CODE]set_row_spacing()[/CODE] and [CODE]set_col_spacing()[/CODE] 
methods. These add spacing between the rows at the specified row or column.

[CODE]
  table.set_row_spacing(row, spacing)
[/CODE]

and

[CODE]
  table.set_col_spacing(column, spacing)
[/CODE]

Note that for columns, the space goes to the right of the column, and for rows, 
the space goes below the row.

You can also set a consistent spacing of all rows and/or columns with:

[CODE]
  table.set_row_spacings(spacing)
[/CODE]

and,

[CODE]
  table.set_col_spacings(spacing)
[/CODE]

Note that with these calls, the last row and last column do not get any spacing.




Table Packing Example

The example program 02Table.vala makes a window with three buttons in a 2x2 
table. The first two buttons will be placed in the upper row. A third, quit 
button, is placed in the lower row, spanning both columns. Figure 4.4, “Packing 
using a Table” illustrates the resulting window:

[IMG file="chapter-04/02Packbox.png"]Figure 4.4. Packing using a Table[/IMG]

Here's the source code:

[CODE]

using Gtk;

class Table {
  
  private Gtk.Window window;
  
  /* Our callback.
   * The data passed to this method is printed to stdout */
  void callback(string data) {
    stdout.printf("Hello again - %s was pressed\n", data);
  }

  /* This callback quits the program. */
  public bool delete_event() {
    Gtk.main_quit();
    return false;
  }

  public Table () {
    /* Create a new window. */
    this.window = new Gtk.Window(Gtk.WindowType.TOPLEVEL);

    /* Set the window title. */
    this.window.set_title("Table");

    /* Set a handler for delete_event that immediately
     *exits Gtk. */
    this.window.delete_event.connect(this.delete_event);

    /* Sets the border width of the window. */
    this.window.set_border_width(20);

    /* Create a 2x2 table. */
    var table = new Gtk.Table(2, 2, true);

    /* Put the table in the main window. */
    this.window.add(table);

    /* Create first button. */
    var button = new Gtk.Button.with_label("button 1");
  
    /* When the button is clicked, we call the "callback" method
     * with a pointer to "button 1" as its argument. */
    button.clicked.connect( ()=>{ this.callback("button 1"); });
    /* Insert button 1 into the upper left quadrant of the table. */
    table.attach_defaults(button, 0, 1, 0, 1);
    button.show();

    /* Create second button. */
    button = new Gtk.Button.with_label("button 2");
    /* When the button is clicked, we call the "callback" method
     * with a pointer to "button 2" as its argument */
    button.clicked.connect( () => { this.callback("button 2"); } );
    /* Insert button 2 into the upper right quadrant of the table. */
    table.attach_defaults(button, 1, 2, 0, 1);

    button.show();

    /* Create "Quit" button */
    button = new Gtk.Button.with_label("Quit");

    /* When the button is clicked, we call the main_quit function
     * and the program exits. */
    button.clicked.connect( ()=> { Gtk.main_quit(); });

    /* Insert the quit button into the both lower quadrants of the table */
    table.attach_defaults(button, 0, 2, 1, 2);

    button.show();

    table.show();
    this.window.show();
  }
  
  public static int main(string[] args) {
    
    Gtk.init(ref args);
    
    new Table();
    
    Gtk.main();
    
    return 0;
  }

}

[/CODE]

The Table class is defined in line 5-88. Lines 11-13 define the 
[CODE]callback()[/CODE] method which is called when two of the buttons are 
"clicked". The callback just prints a message to the console indicating which 
button was pressed using the passed in string data.

Lines 16-19 define the [CODE]delete_event()[/CODE] method which is called when 
the window is slated for deletion by the window manager.

Lines 21-75 define the Table constructor [CODE]Table()[/CODE]. It creates a 
window (line 23), sets the window title (line 26), connects the 
[CODE]delete_event()[/CODE] callback to the "delete_event" signal (line 30), and 
sets the border width (line 33). A [CODE]Gtk.Table[/CODE] is created in line 36 
and added to the window in line 39.

The two upper buttons are created (lines 43 and 52), their "clicked" signals are 
connected to the [CODE]callback()[/CODE] method (lines 46 and 55), and attached 
to the table in the first row (lines 48 and 57). Lines 62-66 create the "Quit" 
button, connect its "clicked" signal to the [CODE]Gtk.main_quit()[CODE] function 
and attach it to the table spanning the whole second row.
