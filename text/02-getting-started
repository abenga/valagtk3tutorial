GETTING STARTED

Installation

Installing GTK+.

Before you can begin programming, you have to install Gtk+, pkg-config 
and all their dependencies. 

One may install them from source by downloading several archives from
various websites, untarring them and running [CMD]./configure[CMD],
[CMD]./make[/CMD] and [CMD]./make[/CMD] to install them.

If you are using a Linux distribution with a package manager, it is easier
to install the precompiled packages from the distribution's repositories.

You will need to install the -dev packages that contain the header files and 
static libraries that are needed to compile GTK+ applications. Installing 
these the GTK+ development packages will also install all its dependecies (the 
header files for GLib, gdk-pixbuf, etc).

On Ubuntu/Debian, this would be:

[CMD]
  # aptitude install libgtk-3-dev
[/CMD]

On Fedora, one would use:
[CMD]
  # yum install libgtk-3-dev
[/CMD]


Installing Vala

You may install Vala by building from source. First, one obtains the 
vala source code by downloading a tarball from the vala releases page 
(http://live.gnome.org/Vala/Release).

You will then extract it and run [CMD]./configure[/CMD], [CMD]make[/CMD] and 
[CMD]make install[/CMD] in the source folder.

Alternatively (this is probably the recommended way for newcomers), you may 
install vala from your distro's repositories.

For example, on Debian or Ubuntu, one would run:
[CMD]
  # aptitude install valac
[/CMD]

And for Fedora, one would run:
[CMD]
  # yum install valac
[/CMD]

You may also use your distribution's graphical software management tools like the
Ubuntu Software Centre or Synaptic.


A First Program

Our first program will create a 200px by 200px window. This program cannot be 
stopped, except by killing it at the shell.

[CODE lang='vala' file='chapter-02/01SimpleWindow.vala']
using Gtk;

int main(string[] args) {
  Gtk.init (ref args);
  
  Gtk.Window window = new Window();
  window.show_all();
  
  Gtk.main ();
  
  return 0;
}
[/CODE]


You can compile the program above by using
[CMD]
  valac --pkg gtk+-3.0 -o simplewindow 01-simple-window.vala
[/CMD]

[CMD]valac[/CMD] is the name of the vala compiler. [CMD]--pkg gtk+3.0[/CMD] 
tells the vala compiler to include the Gtk+ header files in the compilation. 
The [CMD]-o[/CMD] flag tells the compiler what to call the compiled executable, 
in this  case [CMD]simplewindow[/CMD]. If this is omitted, the binary will 
have the same  name as the compiled file (in this case it would be 
[CMD]simple-window[/CMD]) The final argument is the name of the vala 
file we are compiling.

If compilation succeeds, one may execute the program by typing

[CMD]
  ./simplewindow
[/CMD]

into the console. Just closing the window does not kill the program,
however. (the window closes, but the program keeps running) To stop 
execution of the program, you have to press CTR+c (or 
CMD+c) on the command line.

The line 

[CODE]
  using Gtk;
[/CODE]

informs the compiler to include the Gtk+ header file which declares the 
variables, functions, structures, etc. that will be used in your GTK 
application.

Execution of this application begins by calling the main function which 
takes the command line arguments passed to the program as argument 
(passed as an array of strings) and returns an integer (traditionally 0 on 
success and 1 on failure).

The line 

[CODE]  
  Gtk.init(ref args)
[/CODE]

is the initialization function for GTK+; this function will set up GTK+, 
the type system, the connection to the windowing environment, etc.
[CODE]Gtk.init()[/CODE] takes as arguments a reference to the command line 
arguments  that were passed to the program; this allows GTK+ to parse 
specific command line arguments that control the behavior of GTK+ itself. The 
parsed arguments will be removed from the array, leaving the unrecognized 
ones for your application to parse.

The next two lines:

[CODE]
  Gtk.Window window = new Window();
  window.show_all();
[/CODE]

create and display a window. The window constructor [CODE]Window()[/CODE] 
takes a window type (one of [CODE]WindowType.TOPLEVEL[/CODE] and 
[CODE]WindowType.POPUP[/CODE]) as an argument that defines how the 
window will be drawn. The default value is 
[CODE]WindowType.TOPLEVEL[/CODE] which specifies that we want the window 
to undergo window manager decoration and placement. Rather than create a 
window of 0x0 size, a window without children is set to 200x200 by 
default so you can still manipulate it.

The last line

[CODE]
  Gtk.main();
[/CODE]

enters the GTK main processing loop. This is a  call you will see in 
every GTK application. When control reaches this point, GTK will sleep 
waiting for X events (such as button or key presses), timeouts, or file 
IO notifications to occur. In our simple example, however, events are 
ignored.


Hello World

Here we will create a program with a button that prints out "Hello World"
to the console each time it is pressed.


[CODE lang='vala' file="chapter-02/02HelloWorld.vala"]
using Gtk;

class HelloWorld {
  
  /* This is a callback function. The data arguments are ignored
     in this example. More on callbacks below. */
  public void hello () {
    stdout.printf("Hello World\n");
  }
  
  
  public bool delete_event () {
    /* If you return FALSE in the "delete_event" signal handler,
       GTK will emit the "destroy" signal. Returning TRUE means
       you don’t want the window to be destroyed.
       This is useful for popping up ’are you sure you want to quit?’
       type dialogs. */
    stdout.printf("delete event occurred\n");
    /* Change true to false and the main window will be destroyed with
       a "delete_event". */
    return false;
  }
  
  /* Another callback. */
  public void destroy() {
   Gtk.main_quit();
  }
  
  
  public HelloWorld () {
    /* create a new window */
    Gtk.Window window = new Gtk.Window(); 
    
    /* When the window is given the "delete_event" signal (this is given 
       by the window manager, usually by the "close" option, or on the 
       titlebar), we ask it to call the delete_event () function as 
       defined above. The data passed to the callback function is NULL 
       and is ignored in the callback function. */
    window.delete_event.connect(this.delete_event);
    /* Here we connect the "destroy" event to a signal handler.
       This event occurs when we call gtk_widget_destroy() on the window,
       or if we return FALSE in the "delete_event" callback. */
    window.destroy.connect(this.destroy);
    /* Sets the border width of the window. */
    window.set_border_width(10);
    
    /* Creates a new button with the label "Hello World". */
    Gtk.Button button = new Gtk.Button.with_label("Hello World");
    /* When the button receives the "clicked" signal, it will call the
       function hello() passing it None as its argument.  The hello()
       function is defined above. */
    button.clicked.connect(this.hello);
    /* This packs the button into the window (a GTK container). */
    window.add(button);
    /* The final step is to display this newly created widget. */
    button.show();
    /* and the window */
    window.show();
  }
  
  public static int main(string[] args){
    Gtk.init(ref args);
    
    var helloWorld = new HelloWorld();
    /* All PyGTK applications must have a gtk.main(). Control ends here
       and waits for an event to occur (like a key press or mouse event). */
    Gtk.main();
    return 0;
  }

}
[/CODE]



Compiling Hello World

Vala code is written in files with .vala extensions. Vala does not enforce as 
much structure in how code is arranged in files as a language like Java - it 
does not require packages and class files in the same way. In Vala, structure is 
defined by the text inside each file which describes the logical location of 
the code using constructs such as namespaces. When compiling Vala code, you give 
the compiler a list of the files required, and Vala works out how they fit 
together.

This means that you can put as many classes or functions into a file as you 
want, even combining parts of different namespaces in together. This is not 
necessarily a good idea. To keep your code orderly and well arranged, you'd want
to follow formal conventions.

The source files for the same package are supplied as command line parameters 
to the Vala compiler valac, along with compiler flags.

To compile HelloWorld above, you would use:

[CMD]
  $ valac --pkg gtk+-3.0 -o helloworld 02HelloWorld.vala
[/CMD]

If you do this instead:

[CMD]
  $ valac --pkg gtk+-3.0 -o helloworld 02HelloWorld.vala
[/CMD]

i.e. if you give valac the [CMD]-C[/CMD] switch, it won't compile your program 
into a binary file. Instead it will output the intermediate C code for each of 
your Vala source files into a corresponding C source file, in this case 
02HelloWorld.c. If you look at the content of these files you can see that 
programming a class in Vala is equivalent to the same task in C, but a whole 
lot more succinct.



Theory of Signals and Callbacks

Before we look in detail at HelloWorld, we'll discuss signals and callbacks. 
GTK+ is an event driven toolkit, which means it will sleep in Gtk.main() until 
an event occurs and control is passed to the appropriate function.

This passing of control is done using the idea of "signals". (Note that these 
signals are not the same as the Unix system signals, and are not implemented 
using them, although the terminology is almost identical.) When an event occurs, 
such as the press of a mouse button, the appropriate signal will be "emitted" 
by the widget that was pressed. This is how GTK+ does most of its useful work. 
There are signals that all widgets inherit, such as "destroy", and there are 
signals that are widget specific, such as "toggled" on a toggle button.

To make a button perform an action, we set up a signal handler to catch these 
signals and call the appropriate function. This is done by using a Gtk.Widget 
(from the Glib.Object class) method such as:

[CODE]
  handlerID = object.signal.connect(func)
[/CODE]

for example [CODE]button.clicked.connect(func);[/CODE]



where object is the Gtk.Widget instance which will be emitting the signal, and 
the argument [CODE]func[/CODE] is the "callback function" you wish to be called 
when it is caught. The method returns a handler id that can be used to 
disconnect or block the handler.

[CODE]func[/CODE] is called a "callback function" and is ordinarily a member 
function of a class that subclasses Gtk.Widget.



Events

In addition to the signal mechanism described above, there is a set of events 
that reflect the X event mechanism. Callbacks may also be attached to these 
events.

[CODE]
  event
  button_press_event
  button_release_event
  scroll_event
  motion_notify_event
  delete_event
  destroy_event
  expose_event
  key_press_event
  key_release_event
  enter_notify_event
  leave_notify_event
  configure_event
  focus_in_event
  focus_out_event
  map_event
  unmap_event
  property_notify_event
  selection_clear_event
  selection_request_event
  selection_notify_event
  proximity_in_event
  proximity_out_event
  visibility_notify_event
  client_event
  no_expose_event
  window_state_event
[/CODE]

In order to connect a callback function to one of these events you use the 
method [CODE]connect()[/CODE], as described above, using one of the above 
event names as the name parameter. The callback function (or method) for 
events has a slightly different form than that for signals:

Gdk.Event is a class whose type will depend upon which of the
above events has occurred. In order for us to tell which event has been 
issued each of the possible alternatives has a type member that reflects 
the event being issued. The other components of the event structure will 
depend upon the type of the event. Possible values for the EventType are:

NOTHING: a special code to indicate a null event.

DELETE: the window manager has requested that the toplevel window be hidden or 
destroyed, usually when the user clicks on a special icon in the title bar.

DESTROY: the window has been destroyed.

EXPOSE: all or part of the window has become visible and needs to be redrawn.

MOTION_NOTIFY: the pointer (usually a mouse) has moved.

BUTTON_PRESS: a mouse button has been pressed.

2BUTTON_PRESS: a mouse button has been double-clicked (clicked twice within 
a short period of time). Note that each click also generates a BUTTON_PRESS 
event.

3BUTTON_PRESS: a mouse button has been clicked 3 times in a short period of 
time. Note that each click also generates a BUTTON_PRESS event.

BUTTON_RELEASE: a mouse button has been released.

KEY_PRESS: a key has been pressed.

KEY_RELEASE: a key has been released.

ENTER_NOTIFY: the pointer has entered the window.

LEAVE_NOTIFY: the pointer has left the window.

FOCUS_CHANGE: the keyboard focus has entered or left the window.

CONFIGURE: the size, position or stacking order of the window has changed. 
Note that GTK+ discards these events for WINDOW_CHILD windows.

MAP: the window has been mapped.

UNMAP: the window has been unmapped.

PROPERTY_NOTIFY: a property on the window has been changed or deleted.

SELECTION_CLEAR: the application has lost ownership of a selection.

SELECTION_REQUEST: another application has requested a selection.

SELECTION_NOTIFY: a selection has been received.

PROXIMITY_IN: an input device has moved into contact with a sensing surface 
(e.g. a touchscreen or graphics tablet).

PROXIMITY_OUT: an input device has moved out of contact with a sensing 
surface.

DRAG_ENTER: the mouse has entered the window while a drag is in progress.

DRAG_LEAVE: the mouse has left the window while a drag is in progress.

DRAG_MOTION: the mouse has moved in the window while a drag is in progress.

DRAG_STATUS: the status of the drag operation initiated by the window has 
changed.

DROP_START: a drop operation onto the window has started.

DROP_FINISHED: the drop operation initiated by the window has completed.

CLIENT_EVENT: a message has been received from another application.

VISIBILITY_NOTIFY: the window visibility status has changed.

SCROLL: the scroll wheel was turned

WINDOW_STATE: the state of a window has changed. See Gdk.WindowState for the 
possible window states

SETTING: a setting has been modified.

OWNER_CHANGE: the owner of a selection has changed.

GRAB_BROKEN: a pointer or keyboard grab was broken.

DAMAGE: the content of the window has been changed.

EVENT_LAST: marks the end of the GdkEventType enumeration.

In order to connect a callback function to one of these events you use the 
function object.signal.connect, for example 

[CODE]
  window.destroy.connect(func)
[/CODE]