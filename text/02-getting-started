GETTING STARTED

Installation

Installing GTK+.

Before you can begin programming, you have to install Gtk+, pkg-config 
and all their dependencies. 

One may install them from source by downloading several archives from
various websites, untarring them and running [CMD]./configure[CMD],
[CMD]./make[/CMD] and [CMD]./make[/CMD] to install them.

If you are using a Linux distribution with a package manager, it is easier
to install the precompiled packages from the distribution's repositories.

You will need to install the -dev packages that contain the header files and 
static libraries that are needed to compile GTK+ applications. Installing 
these the GTK+ development packages will also install all its dependecies (the 
header files for GLib, gdk-pixbuf, etc).

On Ubuntu/Debian, this would be:

[CMD]
  # aptitude install libgtk-3-dev
[/CMD]

On Fedora, one would use:
[CMD]
  # yum install libgtk-3-dev
[/CMD]


Installing Vala

You may install Vala by building from source. First, one obtains the 
vala source code by downloading a tarball from the vala releases page 
(http://live.gnome.org/Vala/Release).

You will then extract it and run [CMD]./configure[/CMD], [CMD]make[/CMD] and 
[CMD]make install[/CMD] in the source folder.

Alternatively (this is probably the recommended way for newcomers), you may 
install vala from your distro's repositories.

For example, on Debian or Ubuntu, one would run:
[CMD]
  # aptitude install valac
[/CMD]

And for Fedora, one would run:
[CMD]
  # yum install valac
[/CMD]

You may also use your distribution's graphical software management tools like the
Ubuntu Software Centre or Synaptic.


A First Program

Our first program will create a 200px by 200px window. This program cannot be 
stopped, except by killing it at the shell.

[CODE lang='vala' file='chapter-02/01SimpleWindow.vala']
using Gtk;

int main(string[] args) {
  Gtk.init (ref args);
  
  Gtk.Window window = new Window();
  window.show_all();
  
  Gtk.main ();
  
  return 0;
}
[/CODE]


You can compile the program above by using
[CMD]
  valac --pkg gtk+-3.0 -o simplewindow 01-simple-window.vala
[/CMD]

[CMD]valac[/CMD] is the name of the vala compiler. [CMD]--pkg gtk+3.0[/CMD] 
tells the vala compiler to include the Gtk+ header files in the compilation. 
The [CMD]-o[/CMD] flag tells the compiler what to call the compiled executable, 
in this  case [CMD]simplewindow[/CMD]. If this is omitted, the binary will 
have the same  name as the compiled file (in this case it would be 
[CMD]simple-window[/CMD]) The final argument is the name of the vala 
file we are compiling.

If compilation succeeds, one may execute the program by typing

[CMD]
  ./simplewindow
[/CMD]

into the console. Just closing the window does not kill the program,
however. (the window closes, but the program keeps running) To stop 
execution of the program, you have to press CTR+c (or 
CMD+c) on the command line.

The line 

[CODE]
  using Gtk;
[/CODE]

informs the compiler to include the Gtk+ header file which declares the 
variables, functions, structures, etc. that will be used in your GTK 
application.

Execution of this application begins by calling the main function which 
takes the command line arguments passed to the program as argument 
(passed as an array of strings) and returns an integer (traditionally 0 on 
success and 1 on failure).

The line 

[CODE]  
  Gtk.init(ref args)
[/CODE]

is the initialization function for GTK+; this function will set up GTK+, 
the type system, the connection to the windowing environment, etc.
[CODE]Gtk.init()[/CODE] takes as arguments a reference to the command line 
arguments  that were passed to the program; this allows GTK+ to parse 
specific command line arguments that control the behavior of GTK+ itself. The 
parsed arguments will be removed from the array, leaving the unrecognized 
ones for your application to parse.

The next two lines:

[CODE]
  Gtk.Window window = new Window();
  window.show_all();
[/CODE]

create and display a window. The window constructor [CODE]Window()[/CODE] 
takes a window type (one of [CODE]WindowType.TOPLEVEL[/CODE] and 
[CODE]WindowType.POPUP[/CODE]) as an argument that defines how the 
window will be drawn. The default value is 
[CODE]WindowType.TOPLEVEL[/CODE] which specifies that we want the window 
to undergo window manager decoration and placement. Rather than create a 
window of 0x0 size, a window without children is set to 200x200 by 
default so you can still manipulate it.

The last line

[CODE]
  Gtk.main();
[/CODE]

enters the GTK main processing loop. This is a  call you will see in 
every GTK application. When control reaches this point, GTK will sleep 
waiting for X events (such as button or key presses), timeouts, or file 
IO notifications to occur. In our simple example, however, events are 
ignored.


Hello World

Here we will create a program with a button that prints out "Hello World"
to the console each time it is pressed.


[CODE lang='vala' file="chapter-02/02HelloWorld.vala"]
using Gtk;

class HelloWorld {
  
  /* This is a callback function. The data arguments are ignored
     in this example. More on callbacks below. */
  public void hello () {
    stdout.printf("Hello World\n");
  }
  
  
  public bool delete_event () {
    /* If you return FALSE in the "delete_event" signal handler,
       GTK will emit the "destroy" signal. Returning TRUE means
       you don’t want the window to be destroyed.
       This is useful for popping up ’are you sure you want to quit?’
       type dialogs. */
    stdout.printf("delete event occurred\n");
    /* Change true to false and the main window will be destroyed with
       a "delete_event". */
    return false;
  }
  
  /* Another callback. */
  public void destroy() {
   Gtk.main_quit();
  }
  
  
  public HelloWorld () {
    /* create a new window */
    Gtk.Window window = new Gtk.Window(); 
    
    /* When the window is given the "delete_event" signal (this is given 
       by the window manager, usually by the "close" option, or on the 
       titlebar), we ask it to call the delete_event () function as 
       defined above. The data passed to the callback function is NULL 
       and is ignored in the callback function. */
    window.delete_event.connect(this.delete_event);
    /* Here we connect the "destroy" event to a signal handler.
       This event occurs when we call gtk_widget_destroy() on the window,
       or if we return FALSE in the "delete_event" callback. */
    window.destroy.connect(this.destroy);
    /* Sets the border width of the window. */
    window.set_border_width(10);
    
    /* Creates a new button with the label "Hello World". */
    Gtk.Button button = new Gtk.Button.with_label("Hello World");
    /* When the button receives the "clicked" signal, it will call the
       function hello() passing it None as its argument.  The hello()
       function is defined above. */
    button.clicked.connect(this.hello);
    /* This packs the button into the window (a GTK container). */
    window.add(button);
    /* The final step is to display this newly created widget. */
    button.show();
    /* and the window */
    window.show();
  }
  
  public static int main(string[] args){
    Gtk.init(ref args);
    
    var helloWorld = new HelloWorld();
    /* All PyGTK applications must have a gtk.main(). Control ends here
       and waits for an event to occur (like a key press or mouse event). */
    Gtk.main();
    return 0;
  }

}
[/CODE]



Compiling Hello World

Vala code is written in files with .vala extensions. Vala does not enforce as 
much structure in how code is arranged in files as a language like Java - it 
does not require packages and class files in the same way. In Vala, structure is 
defined by the text inside each file which describes the logical location of 
the code using constructs such as namespaces. When compiling Vala code, you give 
the compiler a list of the files required, and Vala works out how they fit 
together.

This means that you can put as many classes or functions into a file as you 
want, even combining parts of different namespaces in together. This is not 
necessarily a good idea. To keep your code orderly and well arranged, you'd want
to follow formal conventions.

The source files for the same package are supplied as command line parameters 
to the Vala compiler valac, along with compiler flags.

To compile HelloWorld above, you would use:

[CMD]
  $ valac --pkg gtk+-3.0 -o helloworld 02HelloWorld.vala
[/CMD]

If you do this instead:

[CMD]
  $ valac --pkg gtk+-3.0 -o helloworld 02HelloWorld.vala
[/CMD]

i.e. if you give valac the [CMD]-C[/CMD] switch, it won't compile your program 
into a binary file. Instead it will output the intermediate C code for each of 
your Vala source files into a corresponding C source file, in this case 
02HelloWorld.c. If you look at the content of these files you can see that 
programming a class in Vala is equivalent to the same task in C, but a whole 
lot more succinct.



Theory of Signals and Callbacks

Before we look in detail at HelloWorld, we'll discuss signals and callbacks. 
GTK+ is an event driven toolkit, which means it will sleep in Gtk.main() until 
an event occurs and control is passed to the appropriate function.

This passing of control is done using the idea of "signals". (Note that these 
signals are not the same as the Unix system signals, and are not implemented 
using them, although the terminology is almost identical.) When an event occurs, 
such as the press of a mouse button, the appropriate signal will be "emitted" 
by the widget that was pressed. This is how GTK+ does most of its useful work. 
There are signals that all widgets inherit, such as "destroy", and there are 
signals that are widget specific, such as "toggled" on a toggle button.

To make a button perform an action, we set up a signal handler to catch these 
signals and call the appropriate function. This is done by using a Gtk.Widget 
(from the Glib.Object class) method such as:

[CODE]
  handlerID = object.signal.connect(func)
[/CODE]

where object is the Gtk.Widget instance which will be emitting the signal, and 
the argument [CODE]func[/CODE] is the "callback function" you wish to be called 
when it is caught. The method returns a handler id that can be used to 
disconnect or block the handler.

[CODE]func[/CODE] is called a "callback function" and is ordinarily a member 
function of a class that subclasses Gtk.Widget.



Events

In addition to the signal mechanism described above, there is a set of events 
that reflect the X event mechanism. Callbacks may also be attached to these 
events.

[CODE]
  event
  button_press_event
  button_release_event
  scroll_event
  motion_notify_event
  delete_event
  destroy_event
  expose_event
  key_press_event
  key_release_event
  enter_notify_event
  leave_notify_event
  configure_event
  focus_in_event
  focus_out_event
  map_event
  unmap_event
  property_notify_event
  selection_clear_event
  selection_request_event
  selection_notify_event
  proximity_in_event
  proximity_out_event
  visibility_notify_event
  client_event
  no_expose_event
  window_state_event
[/CODE]

In order to connect a callback function to one of these events you use the 
method [CODE]object.connect()[/CODE], as described above, using one of the 
above event names as the name parameter. The callback function (or method) for 
events has a slightly different form than that for signals:

Gdk.Event is a class whose type will depend upon which of the
above events has occurred. In order for us to tell which event has been 
issued each of the possible alternatives has an EventType member that reflects 
the event being issued. The other components of the event structure will 
depend upon the type of the event. Possible values for the EventType are:

NOTHING: a special code to indicate a null event.

DELETE: the window manager has requested that the toplevel window be hidden or 
destroyed, usually when the user clicks on a special icon in the title bar.

DESTROY: the window has been destroyed.

EXPOSE: all or part of the window has become visible and needs to be redrawn.

MOTION_NOTIFY: the pointer (usually a mouse) has moved.

BUTTON_PRESS: a mouse button has been pressed.

2BUTTON_PRESS: a mouse button has been double-clicked (clicked twice within 
a short period of time). Note that each click also generates a BUTTON_PRESS 
event.

3BUTTON_PRESS: a mouse button has been clicked 3 times in a short period of 
time. Note that each click also generates a BUTTON_PRESS event.

BUTTON_RELEASE: a mouse button has been released.

KEY_PRESS: a key has been pressed.

KEY_RELEASE: a key has been released.

ENTER_NOTIFY: the pointer has entered the window.

LEAVE_NOTIFY: the pointer has left the window.

FOCUS_CHANGE: the keyboard focus has entered or left the window.

CONFIGURE: the size, position or stacking order of the window has changed. 
Note that GTK+ discards these events for WINDOW_CHILD windows.

MAP: the window has been mapped.

UNMAP: the window has been unmapped.

PROPERTY_NOTIFY: a property on the window has been changed or deleted.

SELECTION_CLEAR: the application has lost ownership of a selection.

SELECTION_REQUEST: another application has requested a selection.

SELECTION_NOTIFY: a selection has been received.

PROXIMITY_IN: an input device has moved into contact with a sensing surface 
(e.g. a touchscreen or graphics tablet).

PROXIMITY_OUT: an input device has moved out of contact with a sensing 
surface.

DRAG_ENTER: the mouse has entered the window while a drag is in progress.

DRAG_LEAVE: the mouse has left the window while a drag is in progress.

DRAG_MOTION: the mouse has moved in the window while a drag is in progress.

DRAG_STATUS: the status of the drag operation initiated by the window has 
changed.

DROP_START: a drop operation onto the window has started.

DROP_FINISHED: the drop operation initiated by the window has completed.

CLIENT_EVENT: a message has been received from another application.

VISIBILITY_NOTIFY: the window visibility status has changed.

SCROLL: the scroll wheel was turned

WINDOW_STATE: the state of a window has changed. See Gdk.WindowState for the 
possible window states

SETTING: a setting has been modified.

OWNER_CHANGE: the owner of a selection has changed.

GRAB_BROKEN: a pointer or keyboard grab was broken.

DAMAGE: the content of the window has been changed.

EVENT_LAST: marks the end of the GdkEventType enumeration.

In order to connect a callback function to one of these events you use the 
function object.signal.connect, for example 

[CODE]
  window.destroy.connect(func)
[/CODE]




Stepping Through Hello World

Now that we know the theory behind this, let's clarify by walking through the 
example [CMD]02HelloWorld.vala[/CMD] program.

Lines 4-85 define the HelloWorld class that contains all the callbacks as 
object methods and the object instance initialization method. 

Lines 6 and 7 define the members of [CODE]HelloWorld[/CODE]. These are the 
widgets that we will be manipulating in the program.

[CODE]
  private Gtk.Window window;
  private Gtk.Button button;
[/CODE]

Now let's examine the callback methods.

Lines 11-13 define the [CODE]hello()[/CODE] callback method that will be called 
when the button is "clicked". When called the method, prints "Hello World" to the 
console. In this case the data parameter is left out since the [CODE]hello()[/CODE] 
method will never called with user data. The next example will use the data argument to tell us which button was pressed.

[CODE]
  public void hello () {
    stdout.printf("Hello World\n");
  }
[/CODE]

The next callback (lines 15-25) is a bit special. The "delete_event" occurs 
when the window manager sends this event to the application. This happens, for 
example, when the user clicks the close button on the window. We have a choice 
here as to what to do about these events. We can ignore them, make some sort of 
response, or simply quit the application.

The value you return in this callback lets GTK+ know what action to take. By 
returning [CODE]true[/CODE], we let it know that we don't want to have the 
"destroy" signal emitted, keeping our application running. By returning 
[code]false[/code], we ask that "destroy" be emitted, which in turn will call 
our "destroy" signal handler. Note the comments have been removed for clarity.

[CODE]
  public bool delete_event () {
    stdout.printf("delete event occurred\n");
    return false;
  }
[/CODE]

The destroy() callback method (lines 28-30) causes the program to quit by 
calling Gtk.main_quit() . This function tells GTK+ that it is to exit from 
Gtk.main() when control is returned to it.

[CODE]
  public void destroy() {
   Gtk.main_quit();
  }
[/CODE]

Lines 32-71 define the [CODE]HelloWorld[/CODE] constructor 
[CODE]HelloWorld()[/CODE] that creates the window and widgets used by the 
program.

Line 34 creates a new window, but it is not displayed until we direct GTK+ to 
show the window near the end of our program. The window reference is saved in 
the HelloWorld attribute ([code]window[/code]) for later access.

[CODE]
  Gtk.Window window = new Gtk.Window();
[/CODE]

Lines 41 and 48 illustrate two examples of connecting a signal handler to an 
object, in this case, the window. Here, the "delete_event" and "destroy" signals 
are caught. The first is emitted when we use the window manager to close the 
window, or when we use the GtkWidget [CODE]destroy()[/CODE] method call. The 
second is emitted when, in the "delete_event" handler, we return [CODE]false[/CODE].

[CODE]
  window.delete_event.connect(this.delete_event);
  window.destroy.connect(this.destroy);
[/CODE]

Line 48 sets an attribute of a container object (in this case the window) to 
have a blank area along the inside of it 10 pixels wide where no widgets will be 
placed. There are other similar methods that we will look at in [LINK]Chapter 18, 
Setting Widget Attributes[/LINK].

[CODE]
  window.set_border_width(10);
[/CODE]

Line 51 creates a new button and saves a reference to it in self.button. The 
button will have the label "Hello World" when displayed.

[CODE]
  Gtk.Button button = new Gtk.Button.with_label("Hello World");
[/CODE]

In line 56 we attach a signal handler to the button so when it emits the 
"clicked" signal, our [CODE]hello()[/CODE] callback method is called. We are 
not passing any data to [CODE]hello()[/CODE] so we don't pass any arguments. 
The "clicked" signal is emitted when we click the button with our mouse pointer.

[CODE]
  button.clicked.connect(this.hello);
[/CODE]

We are also going to use this button to exit our program. Line 61 illustrates 
how the "destroy" signal may come from either the window manager, or from our 
program. When the button is "clicked", same as above, it calls the 
[CODE]hello()[/CODE] callback first, and then the following one in the order 
they are set up. You may have as many callbacks as you need, and all will be 
executed in the order you connected them.

Since we want to use the GtkWidget [CODE]destroy()[/CODE] method that accepts 
one argument (the widget to be destroyed - in this case the window), we use the 
[CODE]GLib.Signal.connect_swapped()[/CODE] method and pass it the object to             /* Really? */
which we are connecting it to, the signal to watch out for, the callback to 
be run and a reference to the the window to be destroyed. 

When the [CODE]Gtk.Widget destroy()[/CODE] method is called it will cause the 
"destroy" signal to be emitted from the window which will in turn cause the 
HelloWorld [CODE]destroy()[/CODE] method to be called to end the program.

[CODE]
  GLib.Signal.connect_swapped(button,"clicked",(GLib.Callback)destroy, window);
[/CODE]

Line 59 is a packing call, which will be explained in depth later on in Chapter 
4, Packing Widgets . But it is fairly easy to understand. It simply tells GTK+ 
that the button is to be placed in the window where it will be displayed. Note 
that a GTK+ container can only contain one widget. There are other widgets, 
described later, that are designed to layout multiple widgets in various ways.

[CODE]
  window.add(button);
[/CODE]

Now we have everything set up the way we want it to be. With all the signal 
handlers in place, and the button placed in the window where it should be, we 
ask GTK+ (lines 67 and 70) to "show" the widgets on the screen. The window 
widget is shown last so the whole window will pop up at once rather than seeing 
the window pop up, and then the button forming inside of it. Although with such 
a simple example, you'd never notice.

[CODE]
  this.button.show();
  this.window.show();
[/CODE]

Lines 73-82 define the [CODE]main()[/CODE] method. This is the point at which
execution of our program begins.



Line 76 creates an instance of the HelloWorld class and saves a reference to 
it in the [CODE]hello[/CODE] variable. 

In line 80, we call the [CODE]Gtk.main()[/CODE] function which sleeps and waits 
for the user to interact with the program interface.

[CODE]
  Gtk.main()
[/CODE]

Now, when we click the mouse button on a GTK+ button, the widget emits a 
"clicked" signal. In order for us to use this information, our program sets up 
a signal handler to catch that signal, which dispatches the function of our 
choice. In our example, when the button we created is "clicked", the 
[CODE]hello()[/CODE] method is called with no arguments, and then the next 
handler for this signal is called. The next handler calls the widget 
[CODE]destroy()[/CODE] function with the window as its argument thereby causing 
the window to emit the "destroy" signal, which is caught, and calls our 
HelloWorld [CODE]destroy()[/CODE] method

Another course of events is to use the window manager to kill the window, 
which will cause the "delete_event" to be emitted. This will call our 
"delete_event" handler. If we return [CODE]true[/CODE] here, the window will be 
left as is and nothing will happen. Returning [CODE]false[/CODE] will cause 
GTK+ to emit the "destroy" signal that causes the HelloWorld "destroy" callback 
to be called, exiting GTK.